function createSpiralTrack(e){const r=new THREE.BufferGeometry,t=new THREE.MeshBasicMaterial({map:dataTextures[e]}),s=new THREE.Mesh(r,t);s.material.map.repeat.set(1,1/apexProps.spiralCnt),spiralTrackGeometries.push(r),spiralTrackMaterials.push(t),spiralTracks.push(s),scene.add(s)}function setPositions(e){const r=[],t=spineCurve.computeFrenetFrames(spineSteps,!1);for(let r=0;r<spineSteps;r++)t.binormals[r].multiplyScalar(apexProps.radius[e]+r*apexProps.taper[e]);for(let s=0;s<spineSteps-apexProps.wSegments[e]+1;s++){const n=[];for(let r=0;r<apexProps.wSegments[e];r++){const o=t.binormals[s+r].clone(),p=t.normals[s+r].clone(),a=(new THREE.Vector3).crossVectors(o,p).normalize();o.applyAxisAngle(a,s*apexProps.angle[e]*Math.PI/180-apexProps.rotation[e]*Math.PI/180);const i=new THREE.Vector3(spineCurvePoints[s+r].x+o.x,spineCurvePoints[s+r].y+o.y,spineCurvePoints[s+r].z+o.z);n.push(i)}r.push(n)}const s=[],n=[];let o=0;for(let p=0;p<spineSteps-apexProps.wSegments[e];p++){const a=t.binormals[p+1].clone(),i=t.normals[p+1].clone();(new THREE.Vector3).crossVectors(a,i).normalize();for(let t=0;t<apexProps.wSegments[e]-1;t++)s.push(r[p][t].x,r[p][t].y,r[p][t].z),s.push(r[p+1][t+1].x,r[p+1][t+1].y,r[p+1][t+1].z),s.push(r[p][t+1].x,r[p][t+1].y,r[p][t+1].z),s.push(r[p][t].x,r[p][t].y,r[p][t].z),s.push(r[p+1][t].x,r[p+1][t].y,r[p+1][t].z),s.push(r[p+1][t+1].x,r[p+1][t+1].y,r[p+1][t+1].z),n.push(o,t/(apexProps.wSegments[e]-1)/2+.5),n.push(o+apexProps.stepPct[e],(t+1)/(apexProps.wSegments[e]-1)/2+.5),n.push(o,(t+1)/(apexProps.wSegments[e]-1)/2+.5),n.push(o,t/(apexProps.wSegments[e]-1)/2+.5),n.push(o+apexProps.stepPct[e],t/(apexProps.wSegments[e]-1)/2+.5),n.push(o+apexProps.stepPct[e],(t+1)/(apexProps.wSegments[e]-1)/2+.5),s.push(r[p][t].x,r[p][t].y,r[p][t].z),s.push(r[p][t+1].x,r[p][t+1].y,r[p][t+1].z),s.push(r[p+1][t+1].x,r[p+1][t+1].y,r[p+1][t+1].z),s.push(r[p][t].x,r[p][t].y,r[p][t].z),s.push(r[p+1][t+1].x,r[p+1][t+1].y,r[p+1][t+1].z),s.push(r[p+1][t].x,r[p+1][t].y,r[p+1][t].z),n.push(o,t/(apexProps.wSegments[e]-1)/2),n.push(o,(t+1)/(apexProps.wSegments[e]-1)/2),n.push(o+apexProps.stepPct[e],(t+1)/(apexProps.wSegments[e]-1)/2),n.push(o,t/(apexProps.wSegments[e]-1)/2),n.push(o+apexProps.stepPct[e],(t+1)/(apexProps.wSegments[e]-1)/2),n.push(o+apexProps.stepPct[e],t/(apexProps.wSegments[e]-1)/2);o+=apexProps.stepPct[e]}spiralTrackGeometries[e].setAttribute("position",new THREE.BufferAttribute(new Float32Array(s),3)),spiralTrackGeometries[e].setAttribute("uv",new THREE.BufferAttribute(new Float32Array(n),2))}function valueFromRange(e,r){return Math.round(r/255*(e-1))}function valueFromSet(e,r){const t=Math.round((e.length-1)*(r/255));return e[t]}function initSeed(){const e=getHashStr();console.log(e);const r=[],t=[];for(let s=0;s<e.length;s++)r[s]=parseInt(e[s],16),s%2==0&&(t[s/2]=parseInt(e[s]+e[s+1],16));apexProps.camPosZ=[60,70,80,90][t[0]%4],apexProps.curveDir=[-1,1][t[1]%2],apexProps.twistDir=[-1,1][t[2]%2],apexProps.spinePoints=[new THREE.Vector3(0,0,0),null,null,new THREE.Vector3(0,spineH,0)];const s=90+90*apexProps.curveDir,n=valueFromSet([30,45,60,75,90],t[3]);for(let e=0;e<2;e++){const r=Math.cos(s*Math.PI/180)*n,t=90*e-45,o=Math.sin(t*Math.PI/180)*n;apexProps.spinePoints[e+1]=new THREE.Vector3(r,spineH/2+o,0)}apexProps.spineRot=45*apexProps.curveDir;const o=valueFromSet([0,1,2],t[4])/9,p=valueFromSet([0,1,2],t[5])/3,a=valueFromSet([0,1,2],t[6])/9;apexProps.spinePoints.forEach(e=>{e.applyAxisAngle(new THREE.Vector3(o,p,a),apexProps.spineRot*Math.PI/180)}),apexProps.spiralCnt=valueFromSet([1,2,2],t[7]),apexProps.wSegments=[],apexProps.stepPct=[],apexProps.angle=[],apexProps.radius=[],apexProps.taper=[],apexProps.rotation=[],apexProps.rotIncr=[],apexProps.animToggle=[];const i=[0,10,20,30,40,50,60,200,210,220,230,240,250,260,270,280,290,300],l=valueFromRange(i.length,t[8]),c=0,m=.05;clrScheme.bg=(new THREE.Color).setHSL(l/360,c,m),clrScheme.tracks=[];for(let e=0;e<apexProps.spiralCnt;e++){apexProps.wSegments[e]=41-25*e,apexProps.stepPct[e]=1/(spineSteps-apexProps.wSegments[e]),apexProps.angle[e]=(4+3*e)*apexProps.twistDir,apexProps.radius[e]=8+5*e,apexProps.taper[e]=.1+.05*e,apexProps.rotation[e]=360*e/apexProps.spiralCnt,apexProps.rotIncr[e]=(-1-.5*e)*apexProps.twistDir,apexProps.animToggle[e]=1;const r=valueFromRange(i.length,t[9+e]);let s=r+2;s>i.length-1&&(s-=i.length);const n=(new THREE.Color).setHSL(i[r]/360,1,.5),o=(new THREE.Color).setHSL(i[s]/360,1,.5),p=[n,o],a=valueFromRange(i.length,t[11+e]);let l=a+2;l>i.length-1&&(l-=i.length);const c=(new THREE.Color).setHSL(i[a]/360,1,.5),m=(new THREE.Color).setHSL(i[l]/360,1,.5),x=[c,m];clrScheme.tracks[e]=[p,x]}console.log("apexProps",apexProps)}function init(){const e=document.querySelector("#c");clock=new THREE.Clock,delta=0,interval=1/30,renderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),renderer.setPixelRatio(window.devicePixelRatio),renderer.setSize(e.clientWidth,e.clientHeight),scene=new THREE.Scene,scene.background=clrScheme.bg;{const r=90,t=e.clientWidth/e.clientHeight,s=.1,n=500;camera=new THREE.PerspectiveCamera(r,t,s,n),camera.position.z=apexProps.camPosZ}controls=new OrbitControls(camera,e),controls.enablePan=!1,controls.enableRotate=!1,controls.enableZoom=!1,stats=new Stats,document.querySelector(".center").appendChild(stats.domElement);{renderTarget=new THREE.WebGLRenderTarget(rtWidth,rtHeight);const e=0,r=rtWidth,t=0,s=-rtHeight,n=-1,o=1;rtScene=new THREE.Scene,rtCamera=new THREE.OrthographicCamera(e,r,t,s,n,o);const p=new THREE.PlaneGeometry(rtWidth,rtHeight/apexProps.spiralCnt/2);p.computeBoundingBox();const a=rtHeight/apexProps.spiralCnt/2/2;let i=1;for(let e=0;e<apexProps.spiralCnt;e++){for(let r=0;r<2;r++){for(let t=0;t<2;t++){const s=new THREE.Group,n=0==r?t:1-t,o=clrScheme.tracks[e][n][0],p=clrScheme.tracks[e][n][1];for(let e=0;e<sprCols;e++){const r=1*e/sprCols,n=sprW/2+sprW*e,l=(new THREE.Color).copy(o).lerp(p,r),c=new THREE.SpriteMaterial({color:l}),m=new THREE.Sprite(c);m.position.set(n,-a*i,0),m.scale.set(sprW-sprW*t,rtHeight/apexProps.spiralCnt/2,0),s.add(m)}t%2==1&&spriteGroups.push(s),rtScene.add(s)}i+=2}pixelArrays.push(new Uint8Array(rtWidth*rtHeight*4))}}spineCurve=new THREE.CubicBezierCurve3(apexProps.spinePoints[0],apexProps.spinePoints[1],apexProps.spinePoints[2],apexProps.spinePoints[3]),spineCurvePoints=spineCurve.getPoints(spineSteps-1)}function animate(){if(requestAnimationFrame(animate),delta+=clock.getDelta(),delta>interval){if(doAnim||animCnt!=animInt){if(doAnim)if(animTrack>-1)for(let e=0;e<2;e++){let r=e+2*animTrack;for(let t=0;t<spriteGroups[e].children.length;t++){const s=t,n=s+animLength;animCnt>=s&&animCnt<=n?spriteGroups[r].children[t].scale.x+=sprW/animLength*apexProps.animToggle[animTrack]:(1==apexProps.animToggle[animTrack]&&spriteGroups[r].children[spriteGroups[r].children.length-1].scale.x==sprW||-1==apexProps.animToggle[animTrack]&&0==spriteGroups[r].children[spriteGroups[r].children.length-1].scale.x)&&doAnim&&1==e&&(doAnim=!1,animCnt=0,apexProps.animToggle[animTrack]*=-1)}}else doAnim=!1,animCnt=0}else doAnim=!0,animCnt=0,animTrack=Math.floor(Math.random()*(apexProps.spiralCnt+1))-1;if(animCnt++,spiralTracks.length)for(let e=0;e<apexProps.spiralCnt;e++)apexProps.rotation[e]+=apexProps.rotIncr[e],setPositions(e),spiralTracks[e].material.map.needsUpdate=!0;delta%=interval}render(),stats.update()}function render(){renderer.setRenderTarget(renderTarget),renderer.render(rtScene,rtCamera);for(let e=0;e<apexProps.spiralCnt;e++){const r=e*rtHeight/apexProps.spiralCnt;renderer.readRenderTargetPixels(renderTarget,0,r,rtWidth,rtHeight/apexProps.spiralCnt,pixelArrays[e]),dataTextures[e]=new THREE.DataTexture(pixelArrays[e],rtWidth,rtHeight)}renderer.setRenderTarget(null),renderer.render(scene,camera)}import*as THREE from"../three.js-r124/build/three.module.js";import Stats from"../three.js-r124/examples/jsm/libs/stats.module.js";import{OrbitControls}from"../three.js-r124/examples/jsm/controls/OrbitControls.js";let camera,scene,renderer,stats,controls,clock,delta,interval,renderTarget,rtCamera,rtScene;const spineH=100;let spineCurve;const spineSteps=251;let spineCurvePoints;const rtWidth=6e3,rtHeight=100,sprCols=200,sprW=rtWidth/sprCols,spriteGroups=[];let animTrack,doAnim=!1,animCnt=0;const animInt=300,animLength=40,spiralTrackGeometries=[],spiralTrackMaterials=[],spiralTracks=[],pixelArrays=[],dataTextures=[],apexProps={},clrScheme={};initSeed(),init(),animate();for(let e=0;e<apexProps.spiralCnt;e++)if(createSpiralTrack(e),setPositions(e),e==apexProps.spiralCnt-1){const r=new THREE.Group,t=spineCurve.computeFrenetFrames(spineSteps,!1),s=[0,Math.floor(spineSteps/2),spineSteps-1];for(let n of s){t.binormals[n].multiplyScalar(apexProps.radius[e]+n*apexProps.taper[e]);const s=t.binormals[n].clone(),o=t.normals[n].clone(),p=(new THREE.Vector3).crossVectors(s,o).normalize(),a=[];for(let e=0;e<31;e++){const e=Math.PI/180*12;s.applyAxisAngle(p,e),a.push(new THREE.Vector3(spineCurvePoints[n].x+s.x,spineCurvePoints[n].y+s.y,spineCurvePoints[n].z+s.z))}const i=(new THREE.BufferGeometry).setFromPoints(a),l=new THREE.LineBasicMaterial({color:16776960}),c=new THREE.Line(i,l);r.add(c)}const n=(new THREE.Box3).setFromObject(r);spiralTracks.forEach(e=>{e.position.x=-(n.min.x+n.max.x)/2,e.position.y=-(n.min.y+n.max.y)/2,e.position.z=-(n.min.z+n.max.z)/2})}